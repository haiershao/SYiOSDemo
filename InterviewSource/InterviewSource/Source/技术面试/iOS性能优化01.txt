1.使用ARC管理内存，它不仅能帮组你释放掉不需要的对象，还能提升性能2.在正确的地方使用重用标示符比如在tableView中在 cellForRowAtIndexPath:中给定一个带有重用标示的cell，如果这里不去指定重用的UITableViewCell对象，就会每次显示一行cell就创建一个，这样会对好性能，还会造成滚动卡得现象3尽量把View设置为不透明如果你有不透明的Views，你应该设置它们的opaque属性为YES。原因是这会使系统用一个最优的方式渲染这些views。然而当这个view嵌在scroll view里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响app的性能。在相对比较静止的画面中，设置这个属性不会有太大影响 4不要阻塞主线程因为UIKit在主线层上做所有工作，UI界面的更新，触摸等，如果你要是一直去使用主线层，这会存在APP失去反应的现象中级性能提升5延迟加载Views如果有许多的views去加载渲染，这就导致消CPU和内存的消耗，在我们需要他的时候再去创建。用第一种方案的话因为你需要一开始就创建一个view并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的app操作更敏感因为当用户点击按钮的时候它只需要改变一下这个view的可见性。第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。7缓存不大可能改变但是需要经常读取的东西需要缓存新特性存储的版本号。[NSUserDefaults standardUserDefaults]8 正确设定背景图片在View里放背景图片就像很多其它iOS编程一样有很多方法:1	使用UIColor的 colorWithPatternImage来设置背景色；2	在view中添加一个UIImageView作为一个子View。如果你使用全画幅的背景图，你就必须使用UIImageView为背景的。这种情形下使用UIImageView可以节约不少的内存：123 // You could also achieve the same result in Interface BuilderUIImageView *backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"background"]];[self.view addSubview:backgroundView];如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存：1	self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@"background"]];。9 选择正确的数据存储选项当存储大块数据时你会怎么做？你有很多选择，比如：3	使用`NSUerDefaults`4	plist5	使用NSCoding存档6	使用类似SQLite的本地SQL数据库7	使用 Core DataNSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了NSCoding？不幸的是，它也需要读写文件，你需要读取整个文件到内存里去解析，这样是很不经济的。在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧*** 加速启动时间你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。还是那句话，避免过于庞大的XIB，因为他们是在主线程上加载的***选择是否缓存图片常见的从bundle中加载图片的方式有两种，一个是用`imageNamed`，二是用`imageWithContentsOfFileimageNamed`的优点是当加载时会缓存图片，而后者不会。那么我们应该如何选择呢？如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用`imageWithContentsOfFile`足矣，这样不会浪费内存来缓存它。但是要是反复使用的花就用imageNamed
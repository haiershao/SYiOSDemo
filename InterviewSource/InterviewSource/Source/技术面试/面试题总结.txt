1 简诉苹果的开发框架。
答：分4层，分别为Cocoa Touch层，多传媒层 （Medias），核心服务层 （Core Services），核心OS层 （Core OS）。
Cocoa Touch 的UIKit框架提供一系列的Class（类）来创建个管理iPhone OS 的应用程序的用户界面接口应用程序对象、事件控制、绘图模型、窗口、视图和用于控制触摸屏等的接口。
Medias 的 Core Graphics 框架，能够添加2D绘画和合成功能。
Core Services 层的 Foundation 框架为所以的应用提高基本的系统服务。

2 常用的iOS 设计层模式有哪些。
MVC 设计模式，观察者模式，单列类模式，工厂模式，委托模式。


3 继承跟类别的区别，为什么要有类别的存在。
category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。
并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。
类别主要有3个作用：
(1)将类的实现分散到多个不同文件或多个不同框架中。
(2)创建对私有方法的前向引用。
(3)向对象添加非正式协议。
 继承可以增加，修改或者删除方法，并且可以增加属性。

4 简述下ios6 新增的特性。
电话，地图，passBook ，faceBook，siri. 隐私。

5 ARC机制原理
自动引用计数。
ARC是iOS 5推出的新功能，代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。简单地理解ARC，就是通过指定的语法，让编译器(LLVM 3.0)在编译代码时，自动生成实例的引用计数管理部分代码。有一点，ARC并不是GC，它只是一种代码静态分析（Static Analyzer）工具。
’
Automatic Reference Counting，自动引用技术，即ARC 。ARC是Objective-C编译器的特性，而不是运行时特性或者垃圾回收机制，ARC所做的只不过是在代码编译时为你自动在合适的位置插入release或autorelease，就如同之前MRC时你所做的那样。把非ARC工程如何转换成ARC工程也说一下，还有-fno-objc-arc和-fobjc-arc也说一下。

6 简单编写一个block 代理
typedef int（^sum）= (int ,int);
@property (retain,nonatomic) sum sum;
sum = ^(int a,int b)
{
	return a+b;
};
int c= sun(1,2);

7 怎么解决ios5，ios6中横竖屏的问题
// iOS6.0
-(NSUInteger)supportedInterfaceOrientations{
 
    return UIInterfaceOrientationMaskPortrait;  // 可以修改为任何方向
}
 
-(BOOL)shouldAutorotate{
 
    return YES;
}
 
// iOS5.0
-(BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation{
 
    return (toInterfaceOrientation == UIInterfaceOrientationPortrait);  // 可以修改为任何方向
}



8 MVC 是是吗？有什么特性，为什么在iPhone上广泛运用？

MVC模式考虑三种对象：模型对象、视图对象和控制器对象。模型对象负责应用程序的数据和定义操作数据的逻辑；视图对象知道如何显示应用程序的模型数据；控制器对象是M与V之间的协调者。

1是提高的代码的可复用性，2是便于维护，3是降低内存开销。


9 委托是什么，委托的property声明用什么属性？为什么？
delegate，顾名思义，就是委托他人帮自己去做什么事。也就是当自己做什么事情不方便的时候，就可以建立一个委托，这样就可以委托他人帮自己去实现什么方法。
assign ，防止交叉编译。。

10 项目使用过的第三方库
SBJSON、ASIHttp，SDWebImage。

11 怎么实现TableView 懒加载。
重写如下方法
- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath
{
    UIImage *image = [self getImageForCellAtIndexPath:indexPath];  //从网上取得图片
    [cell.imageView setImage:image];
}

答案：懒汉模式，只在用到的时候才去初始化。也可以理解成延时加载。我觉得最好也最简单的一个列子就是tableView中图片的加载显示了。一个延时载，避免内存过高，一个异步加载，避免线程堵塞。

12 编写一个 singleton 的类。

写一个当前类的类属性(静态属性)和一个类方法(静态方法)，在静态方法里面，判断当前静态属性是否为空，如果为空，那么初始化当前类，指向给静态属性。每次使用时，都使用这个静态方法来拿到当前类的实例。

下面以SurveyRunTimeData为例子：
static SurveyRunTimeData *sharedObj = nil; //第一步：静态实例，并初始化。
@implementation SurveyRunTimeData
+ (SurveyRunTimeData*) sharedInstance  //第二步：实例构造检查静态实例是否为nil
{
    @synchronized (self)
    {
        if (sharedObj == nil)
        {
            [[self alloc] init];
        }
    }
    return sharedObj;
}
+ (id) allocWithZone:(NSZone *)zone //第三步：重写allocWithZone方法
{
    @synchronized (self) {
        if (sharedObj == nil) {
            sharedObj = [super allocWithZone:zone];
            return sharedObj;
        }
    }
    return nil;
}
- (id) copyWithZone:(NSZone *)zone //第四步
{
    return self;
}

13 开发过程中最常见的异常有哪些，列举几个。
指针异常，内存泄漏。数组越界。

14 浅复制和深复制的区别？
答案：浅层复制：只复制指向对象的指针，而不复制引用对象本身。深层复制：复制引用对象本身。意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了两份独立对象本身。用网上一哥们通俗的话将就是：浅复制好比你和你的影子，你完蛋，你的影子也完蛋深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。

15 类别和扩展类的区别
类别在不需要继承的情况下可以扩展类的功能。但类别不能添加类的属性和私有变量。类别可以用来扩展Cocoa中类的方法，也可以用来扩展用户自己的类中的方法。当我们查看系统头文件的时候能发现类似@interfaceNSMutableArray (NSExtendedMutableArray)的类定义，其实这就是类别的定义形式。
扩展类与类别的不同之处在于，括号里不需要写名字。同时也可以在类扩展中定义属性以及私有变量。另一个不同之处在于，类扩展必须与类定义以及类的实现同时编译，也就是说，类扩展只能针对自定义的类，不能给系统类增加类扩展。类扩展定义的方法必须在类的实现中进行实现。如果单独定义类扩展的文件并且只定义属性的话，也需要将类实现文件中包含进类扩展文件，否则会找不到属性的set和get方法。

16 obj 中的协议于java 中的接口概念有何不同
Interface理解为接口概念，于JAVA\C#中的接口有所不同的是Obj-C中的接口应该理解为一种非正式协议，Obj-C中的Interface只是表明应该会处理其中声明的消息(方法)，但是不是必须处理。

17 .内存泄露如何检查
在开发的时候内存泄漏是不可避免的，但是也是我们需要尽量减少的，因为内存泄漏可能会很大程度的影响程序的稳定性！！！
1.静态分析
通过静态分析我们可以最初步的了解到代码的一些不规范的地方或者是存在的内存泄漏，这是我们第一步对内存泄漏的检测。当然有一些警告并不是我们关心的可以略过。
2.通过instruments来检查内存泄漏
这个方法能粗略的定位我们在哪里发生了内存泄漏。方法是完成一个循环操作，如果内存增长为0就证明我们程序在该次循环操作中不存在内存泄漏，如果内存增长不为0那证明有可能存在内存泄漏，当然具体问题需要具体分析。
3.代码测试内存泄漏
在做这项工作之前我们要注意一下，在dealloc的方法中我们是否已经释放了该对象所拥有的所有对象。观察对象的生成和销毁是否配对。准确的说就是init（创建对象的方法）和dealloc是否会被成对触发（简单说来就是走一次创建对象就有走一次dealloc该对象）。


18.如何解决#import循环问题
@class--避免循环引用        主要是用于声明一个类，告诉编译器它后面的名字是一个类的名字，而这个类的定义实现是暂时不用知道的，后面会告诉你.也是因为在@class仅仅只是声明一个类，所以在后面的实现文件里面是需要去#import这个类，这时候才包含了这个被引用的类的所有信息。

19 什么是KVC，KVO
kvc:键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。很多情况下可以简化程序代码。apple文档其实给了一个很好的例子。
kvo:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。具体用到过的一个地方是对于按钮点击变化状态的的监控。

20.oc中可修改和不可以修改类型。
答案：可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。
比如NSArray和NSMutableArray。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。


21.When we call objective c is runtime language what does it mean?
我们说的oc是动态运行时语言是什么意思？
答案：多态。 主要是将数据类型的确定由编译时，推迟到了运行时。
这个问题其实浅涉及到两个概念，运行时和多态。
简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。
多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat;
那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。
也就是不同的对象以自己的方式响应了相同的消息（响应了eat这个选择器）。
因此也可以说，运行时机制是多态的基础？~~~

22 通知和协议的不同之处？
简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。
代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。
只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星要一个发布会，代理人发出处理发布会的消息后，别称B的
发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。
因此控制链（has-a从英语单词大致可以看出，单一拥有和可控制的对应关系。

23 frame和bounds有什么不同？
答案:frame指的是：该view在父view坐标系统中的位置和大小。（参照点是父亲的坐标系统）
bounds指的是：该view在本身坐标系统中 的位置和大小。（参照点是本身坐标系统）


24.#import跟#include有什么区别，@class代表什么意思？
#impor功能与include基本相同，不过它避免了重复引用的问题。
@class就是告诉编译器有这个类存在，即前向声明。

25. 简述什么是协议和委托（代码举例）？
 protocol-协议，就是使用了这个协议后就要按照这个协议来办事，协议要求实现的方法就一定要实现。
delegate-委托，顾名思义就是委托别人办事，就是当一件事情发生后，自己不处理，让别人来处理。
@protocol MyDelegate; 
@interface MyClass: NSObject 
{ 
	id <MyDelegate> delegate; 
} 
// 委托方法 
@protocol MyDelegate 
- (void)didJobs:(NSArray *)args; 
@end 

26.readonly，assign，retain，copy，nonatomic属性的作用？ 
assign用于简单数据类型，如NSInteger,double,bool,retain和copy用于对象，copy用于当a指向一个对象，b也想指向同样的对象的时候，如果用assign，a如果释放，再调用b会crash,如果用copy 的方式，a和b各自有自己的内存，就可以解决这个问题。retain 会使计数器加一，也可以解决assign的问题。另外：atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。在多线程环境下，原子操作是必要的，否则有可能引起错误的结果。附：Setter函数if (property != newValue) {[property release];property = [newValue retain];}‘

70. readwrite，readonly，assign，retain，copy，nonatomic 属性的作用？
@property是 一个属性访问声明，扩号内支持以下几个属性：1，getter=getterName，setter=setterName，设置setter与 getter的方法名2，readwrite,readonly，设置可供访问级别2，assign，setter方法直接赋值，不进行 任何retain操作，为了解决原类型与环循引用问题3，retain，setter方法对参数进行release旧值再retain新值，所有 实现都是这个顺序(CC上有相关资料)4，copy，setter方法进行Copy操作，与retain处理流程一样，先旧值release，再 Copy出新的对象，retainCount为1。这是为了减少对上下文的依赖而引入的机制。5，nonatomic，非原子性访问，不加同步， 多线程并发访问会提高性能。注意，如果不加此属性，则默认是两个访问方法都为原子型事务访问。锁被加到所属对象实例级(我是这么理解的...)。


27.用#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）。
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL 

28.为什么delegate的属性是assign而不是retain？
为了防止delegation两端产生不必要的循环引用，导致无法释放该对象。

29.当程序接到内存警告时会调用那个方法？
- (void)didReceiveMemoryWarning；

30  列举Cocoa中常见的多线程的实现方式？一般什么地方会用到多线程？
NSOperation NSThread,GCD等， 一般用在下载大数据，不想影响用户体验的情况下！

31. 堆和栈的区别?
1.管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。
2.申请大小：栈是向低地址扩展的数据结构，是一块连续的内存的区域，堆是向高地址扩展的数据结构，是不连续的内存区域。
3.碎片问题：堆会造成内存空间的不连续，从而造成大量的碎片，栈则不会存在这个问题，因为栈是先进后出的队列。

32.线程与进程的区别和联系?
进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。程 和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进 程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健 壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

33.What is purpose of delegates?代理的作用？
答案：代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。另外一点，代理可以理解为java中的回调监听机制的一种类似。

34.What is push notification?什么是推送消息？
本地和推送提醒允许你在程序没有在前台运行时向用户发送消息。

35.Polymorphism？关于多态性

答案：多态，子类指针可以赋值给父类。
多态是面向对象3大特性之一，简单的说就是是允许将子类类型的指针赋值给父类类型的指针。


36.Singleton?对于单例的理解
答案：
单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。


37.What is responder chain?说说响应链
答案：响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者（next responder）。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象（如果存在），然后是它的父视图（superview）对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow对象）再到程序（UIApplication对象）。如果整个过程都没有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。

在IOS中，有响应者链对事件进行响应，所有的响应类都是UIResponder的子类，响应者链是一个由不同对象组成的层次结构，其中的每个对象将依次获得响应事件消息的机会。
所有继承自UIResponder的类都是一个响应者，它们可以对系统产生的事件，如点击屏幕做出响应。UIView和UIControl都是UIResponder的派生类，所以它们都可以是响应者。同一个项目中的所有响应者，按着一定的顺序来处理接收到的消息，如果前面的响应者做了响应，则后面的响应者不再接收到事件；如果前面的没做出响应，则后面的响应者会接收到事件，并决定是否做出响应。这种处理事件的响应顺序，就叫做响应者链。


38.Difference between method and selector?方法和选择器有何不同？
答案：selector是一个方法的名字，method是一个组合体，包含了名字和实现.详情可以看apple文档。

39.Is there any garbage collection mechanism in Objective C.?OBC的垃圾回收机制？
答案： OBC2.0有Garbage collection，但是iOS平台不提供。一般我们了解的objective-c对于内存管理都是手动操作的，但是也有自动释放池。但是差了大部分资料，貌似不要和arc机制搞混就好了。系统会不定期的回收retainCount=0的引用，把内存释放掉。


40.NSOperation queue?
答案：存放NSOperation的集合类。操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。网上部分资料提到一点是，虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。这边又有个疑点是，对于队列来说，先进先出的概念是Afunc添加进队列，Bfunc紧跟着也进入队列，Afunc先执行这个是必然的，但是Bfunc是等Afunc完全操作完以后，B才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。但是转念一想其实可以参考银行的取票和叫号系统。因此对于A比B先排队取票但是B率先执行完操作，我们亦然可以感性认为这还是一个队列。但是后来看到一票关于这操作队列话题的文章，其中有一句提到“因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”瞬间觉得这个queue名字有点忽悠人了，还不如pool~综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。


41.Can we use two tableview controllers on one viewcontroller?是否在一个视图控制器中嵌入两个tableview控制器？
答案：一个视图控制只提供了一个View视图，理论上一个tableViewController也不能放吧，只能说可以嵌入一个tableview视图。当然，题目本身也有歧义，如果不是我们定性思维认为的UIViewController，而是宏观的表示视图控制者，那我们倒是可以把其看成一个视图控制者，它可以控制多个视图控制器，比如TabbarController那样的感觉。


42.Can we use one tableview with two different datasources? How you will achieve this?一个tableView是否可以关联两个不同的数据源？你会怎么处理？
答案：首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢？想让列表如何显示，不同的数据源分区块显示？

43.Object－c的类可以多重继承么？可以实现多个接口么？重写一个类的方式用继承好还是分类好？为什么？
Objective-c只支持单继承，如果要实现多继承的话，可以通过类别和协议的方式来实现，cocoa 中所有的类都是NSObject 的子类，多继承在这里是用protocol 委托代理 来实现的。

44.类变量的@protected ,@private,@public,@package声明各有什么含义？9@protected本类和本类的子类可以使用，默认值。
@private只能在本类使用
@public 任何地方都可以使用，但是如果在类的外部使用时，需要用“对象->属性名”调用。
@package 包内可以使用，但需要用“对象->属性名”调用。

45.id 声明的对象有什么特性？
答案：id是个很重要的类型，是个可以指向任何类型的指针或者可以理解为指向任何未知类型的指针。

47.对于语句NSString* testObject，m = [[NSData alloc] init];testObject 在编译时和运行时分别是什么类型的对象？
答案：编译时是NSString，运行时是NSData。

48.什么是安全释放？
答案： 把变量释放掉时，需要先release，再设置成nil。这是为了在其他地方，如果想要判断当前变量，是否被释放时，可以直接判断是否是nil，如果nil了，那就说明被释放掉了；用retainCount做判断，如果当前对象已经被释放了，那么程序会崩溃。if（object）｛[object release]; object = nil;｝

49.property中属性retain,copy,assgin的含义分别是什么？有什么区别？将其转换成get／set方法怎么做？有什么注意事项？
答案：Retain把当前对象的retainCount+1, 内存地址不变。
	Copy是retainCount从1开始，内存地址改变。
	Assgin是直接赋值，不涉及到内存操作。
Set方法：
	Retain，[old release]; old = [new retain];
	Copy,    [old release]; old = [new copy];
	Assgin, old = new;
注意事项：
	规范上NSString做属性都是写成copy的，理论上应该是复制了字符串而不是单纯的增加引用计数，其实问题只会出现在把NSMutableString赋值给NSString的时候。当使用retain方式的时候，NSMutableString的内容变化时，语义上应该不可变的NSString也变化了，而用copy则是始终保持赋值时的内容。


50.Cocoa中有虚基类的概念么？怎么简洁的实现？
答案：没有虚基类，可以用类别的形式实现。
虚基类的概念：http://baike.baidu.com/view/1267123.htm

51 在一个对象释放前.如果他被加到了notificationCenter 中.不在notificationcenter中remove这个对象可能会出现什么问题？
答案：程序无法找到当前的通知，会崩溃。


52.什么是序列化或者Acrchiving,可以用来做什么,怎样与copy结合,原理是什么?.
答案：自定义的对象，实现NSCoding协议，使用归档，可以让自定义的对象，转成NSData类型，写入到本地文件。

53.在iphone上有两件事情要做,请问是在一个线程里按顺序做效率高还是两个线程里做效率高？为什么？
答案：两个线程效率高，随便说个单车道和双车道的例子。

54.ios平台怎么做数据的持久化?coredata和sqlite有无必然联系？coredata是一个关系型数据库吗？
iOS中可以有四种持久化数据的方式： 属性列表、对象归档、SQLite3和Core Data；core data可以使你以图形界面的方式快速的定义app的数据模型，同时在你的代码中容易获取到它。core data提供了基础结构去处理常用的功能，例如保存，恢复，撤销和重做，允许你在app中继续创建新的任务。在使用core data的时候，你不用安装额外的数据库系统，因为core data使用内置的sqlite数据库。core data将你app的模型层放入到一组定义在内存中的数据对象。core data会追踪这些对象的改变，同时可以根据需要做相反的改变，例如用户执行撤销命令。当core data在对你app数据的改变进行保存的时候，core data会把这些数据归档，并永久性保存。
mac os x中sqlite库，它是一个轻量级功能强大的关系数据引擎，也很容易嵌入到应用程序。可以在多个平台使用，sqlite是一个轻量级的嵌入式sql数据库编程。与core data框架不同的是，sqlite是使用程序式的，sql的主要的API来直接操作数据表。
Core Data不是一个关系型数据库，也不是关系型数据库管理系统(RDBMS)。虽然Core Dta支持SQLite作为一种存储类型，但它不能使用任意的SQLite数据库。Core Data在使用的过程种自己创建这个数据库。Core Data支持对一、对多的关系。

55.阐述一个nil对象从interface bulider产生，到载入程序运行空间，最后被释放时所经历的生命周期.
答案：awakeFromNib -> loadView -> viewDidLoad -> viewWillAppear -> viewWillLayoutSubviews -> viewDidLayoutSubviews -> viewDidAppear -> viewWillDisappear -> viewDidDisappear -> dealloc
内存不足会触发didReceiveMemoryWarning方法。

56.notification是同步还是异步? kvo是同步还是异步？notification是全进程空间的通知吗？kvo呢？
都是异步的，通知在注册的时候，有一个参数，可以设置哪些类不相应；KVO在注册的时候，有一个参数，设置相应的类。

57.unix上进程怎么通信？
   UNIX主要支持三种通信方式：
   1. 基本通信：主要用来协调进程间的同步和互斥
   (1)锁文件通信
      通信的双方通过查找特定目录下特定类型的文件(称锁文件)来完成进程间  对临界资源访问时的互斥；例如进程p1访问一个临界资源，首先查看是否有一个特定类型文件，若有，则等待一段时间再查找锁文件。
   (2)记录锁文件
   2. 管道通信：适应大批量的数据传递
   3. IPC    ：适应大批量的数据传递

58.timer的间隔周期准吗？为什么？怎样实现一个精准的timer?
误差的原因：定时器到时间后产生定时中断，然后事件触发后调用到你的selector可能花费了较长时间。比如说：一开始的调用OK，没问题。但是你选中了repeat之后，定时器在到时间后不会被停止，又在走时。如果系统在定时器事件到达后花费了10ms才调用到了你的selector，那么这个时间差就会不断地被积累。

比较好的做法是：设置300ms左右一次定时，然后用Ga大的方法，通过时间差来计算是否超过了1s，如果超过的话就加1并且更新基准值，呵呵。除此之外，如果你的线程执行占用时间很小的话可以每次利用线程循环进行不断地轮询定时器的时间，不断求差值。最好设定一个起始的标准时间保存下来，然后拿现在的系统时间减去当时开始的时间

59.UIscrollVew用到了什么设计模式？还能再foundation库中找到类似的吗？（答案众多，不知道哪个是对的～～）
模板(Template)模式，所有datasource和delegate接口都是模板模式的典型应用，
组合模式composition，所有的container view都用了这个模式
观察者模式observer，所有的UIResponder都用了这个模式。

60. 列举几种进程的同步机制，并比较其优缺点。
答案：  原子操作 信号量机制    自旋锁    管程，会合，分布式系统 
进程之间通信的途径
答案：共享存储系统消息传递系统管道：以文件系统为基础 
进程死锁的原因
答案：资源竞争及进程推进顺序非法 
死锁的4个必要条 件
答案：互斥、请求保持、不可剥夺、环路 
死锁的处理
答案：鸵鸟策略、预防策略、避免策略、检测与解除死锁

61. 什么是键-值,键路径是什么? 
模型的性质是通过一个简单的键（通常是个字符串）来指定的。视图和控制器通过键 来查找相应的属性值。在一个给定的实体中，同一个属性的所有值具有相同的数据类型。键-值编码技术用于进行这样的查找—它是一种间接访问对象属性的机制。
键路径是一个由用点作分隔符的键组成的字符串，用于指定一个连接在一起的对象性 质序列。第一个键的性质是由先前的性质决定的，接下来每个键的值也是相对于其前面的性质。键路径使您可以以独立于模型实现的方式指定相关 对象的性质。通过键路径，您可以指定对象图中的一个任意深度的路径，使其指向相关对象的特定属性。

62. c和obj-c如何混用
1）obj-c的编译器处理后缀为m的文件时，可以识别obj-c和c的代码， 处理mm文件可以识别obj-c,c,c++代码，但cpp文件必须只能用c/c++代码，而且cpp文件include的头文件中，也不能出现obj- c的代码，因为cpp只是cpp2) 在mm文件中混用cpp直接使用即可，所以obj-c混cpp不是问题3）在cpp中混用obj- c其实就是使用obj-c编写的模块是我们想要的。如果模块以类实现，那么要按照cpp class的标准写类的定义，头文件中不能出现obj-c的东西，包括#import cocoa的。实现文件中，即类的实现代码中可以使用obj-c的东西，可以import,只是后缀是mm。如果模块以函数实现，那么头文件要按 c的格式声明函数，实现文件中，c++函数内部可以用obj-c，但后缀还是mm或m。

总结：只要cpp文件和cpp include的文件中不包含obj-c的东西就可以用了，cpp混用obj-c的关键是使用接口，而不能直接使用实现代码，实际上cpp混用的是 obj-c编译后的o文件，这个东西其实是无差别的，所以可以用。obj-c的编译器支持cpp.


63. 目标-动作机制
目标是动作消息的接收者。一个控件，或者更为常见的是它的单元，以插座变量（参 见"插座变量"部分）的形式保有其动作消息的目标。
动作是控件发送给目标的消息，或者从目标的角度看，它是目标为了响应动作而实现 的方法。
程序需要某些机制来进行事件和指令的翻译。这个机制就是目标-动作机制。



64. objc的内存管理
如果您通过分配和初始化（比如[[MyClass alloc] init]）的方式来创建对象，您就拥有这个对象，需要负责该对象的释放。这个规则在使用NSObject的便利方法new 时也同样适用.
如果您拷贝一个对象，您也拥有拷贝得到的对象，需要负责该对象的释放.
如果您保持一个对象，您就部分拥有这个对象，需要在不再使用时释放该对象。
如果您从其它对象那里接收到一个对象，则您不拥有该对象，也不应该释放它（这个规则有少数的例外，在参考文档中有显式的说明）。

65. 自动释放池是什么,如何工作
 当您向一个对象发送一个autorelease消息时，Cocoa就会将该对 象的一个引用放入到最新的自动释放池。它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置 时，自动释放池就会被释放，池中的所有对象也就被释放。
ojc-c 是通过一种"referring counting"(引用计数)的方式来管理内存的, 对象在开始分配内存(alloc)的时候引用计数为一,以后每当碰到有copy,retain的时候引用计数都会加一, 每当碰到release和autorelease的时候引用计数就会减一,如果此对象的计数变为了0, 就会被系统销毁.2. NSAutoreleasePool 就是用来做引用计数的管理工作的,这个东西一般不用你管的.3. autorelease和release没什么区别,只是引用计数减一的时机不同而已,autorelease会在对象的使用真正结束的时候才做引用计数 减一.

66. 类工厂方法是什么
 类工厂方法的实现是为了向客户提供方便，它们将分配和初始化合在一个步骤中， 返回被创建的对象，并进行自动释放处理。这些方法的形式是+ (type)className...（其中 className不包括任何前缀）。
工厂方法可能不仅仅为了方便使用。它们不但可以将分配和初始化合在一起，还可以 为初始化过程提供对象的分配信息。
类工厂方法的另一个目的是使类（比如NSWorkspace）提供单件实例。虽 然init...方法可以确认一个类在每次程序运行过程只存在一个实例，但它需要首先分配一个“生的”实例，然后还必须释放该实例。工厂 方法则可以避免为可能没有用的对象盲目分配内存。

67. 单件实例是什么
Foundation 和 Application Kit 框架中的一些类只允许创建单件对象，即这些类在当前进程中的唯一实例。举例来说，NSFileManager 和NSWorkspace 类在使用时都是基于进程进行单件对象的实例化。当向这些类请求实例的时候，它们会向您传递单一实例的一个引用，如果该实例还不存在，则首先进行实例的分配 和初始化。 单件对象充当控制中心的角色，负责指引或协调类的各种服务。如果类在概念上只有一个实例（比如NSWorkspace），就应该产生 一个单件实例，而不是多个实例；如果将来某一天可能有多个实例，您可以使用单件实例机制，而不是工厂方法或函数。

68. 动态绑定—在运行时确定要调用的方法
动态绑定将调用方法的确定也推迟到运行时。在编译时，方法的调用并不和代码绑定 在一起，只有在消实发送出来之后，才确定被调用的代码。通过动态类型和动态绑定技术，您的代码每次执行都可以得到不同的结果。运行时因子负责确定消息的接 收者和被调用的方法。 运行时的消息分发机制为动态绑定提供支持。当您向一个动态类型确定了的对象发送消息时，运行环境系统会通过接收者的isa指针定位对象的类，并以此为起点 确定被调用的方法，方法和消息是动态绑定的。而且，您不必在Objective-C 代码中做任何工作，就可以自动获取动态绑定的好处。您在每次发送消息时，

69. obj-c的优缺点
objc优点：  1) Cateogies   2) Posing   3) 动态识别  4) 指标计算   5）弹性讯息传递  6) 不是一个过度复杂的 C 衍生语言  7) Objective-C 与 C++ 可混合编程
缺点:   1) 不支援命名空間   2)  不支持运算符重载
  3） 不支持多重继承
  4） 使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。（如内联函数等），性能低劣。

 71.  什么是retain count?
答案：内存引用计数


72. Objective C中的selector 是什么？
你可以理解 @selector()就是取类方法的编号,他的行为基本可以等同C语言的中函数指针,只不过C语言中，可以把函数名直接赋给一个函数指针，而Objective-C的类不能直接应用函数指针，这样只能做一个@selector语法来取. 它的结果是一个SEL类型。这个类型本质是类方法的编号(函数地址)。

73. 什么是Notification？什么时候用delegate，什么时候用Notification？
观察者模式，controller向defaultNotificationCenter添加自己的notification，其他类注册这个notification就可以收到通知，这些类可以在收到通知时做自己的操作（多观察者默认随机顺序发通知给观察者们，而且每个观察者都要等当前的某个观察者的操作做完才能轮到他来操作，可以用NotificationQueue的方式安排观察者的反应顺序，也可以在添加观察者中设定反映时间，取消观察需要在viewDidUnload 跟dealloc中都要注销）。
delegate针对one-to-one关系，并且reciever可以返回值给sender，notification 可以针对one-to-one/many/none,reciever无法返回值给sender.所以，delegate用于sender希望接受到reciever的某个功能反馈值，notification用于通知多个object某个事件。

74. UIView 和CALayer 有什么区别?
两者最大的区别是，图层不会直接渲染到屏幕上。
1.UIView是iOS系统中界面元素的基础，所有的界面元素都继承自它。它本身完全是由CoreAnimation来实现的（Mac下似乎不是这样）。它真正的绘图部分，是由一个叫CALayer（Core Animation Layer）的类来管理。UIView本身，更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，例如frame，bounds等等，实际上内部都是在访问它所包含的CALayer的

75.UIView的layer树形在系统内部，被系统维护着三份copy（这段理解有点吃不准）。第一份，逻辑树，就是代码里可以操纵的，例如更改layer的属性等等就在这一份。第二份，动画树，这是一个中间层，系统正在这一层上更改属性，进行各种渲染操作。第三份，显示树，这棵树的内容是当前正被显示在屏幕上的内容。这三棵树的逻辑结构都是一样的，区别只有各自的属性。

76.动画的运作UIView的主layer以外（我觉得是这样），对它的subLayer，也就是子layer的属性进行更改，系统将自动进行动画生成，动画持续时间有个缺省时间，个人感觉大概是0.5秒。在动画时间里，系统自动判定哪些属性更改了，自动对更改的属性进行动画插值，生成中间帧然后连续显示产生动画效果。


77.异常exception 怎么捕获？

A：可能会抛出的异常代码块使用@try标记   @catch是指令标记的块，是用于捕捉@try语句抛出的错误

78.请你谈谈同步和异步。

A：异步是一种松散的通讯模式，一方发送消息之后，不需要等待对方回复，即可以接续处理，电子邮件就是最常见的异步通讯模式；同步则是较为紧密的通讯模式，一方发送消息之后，需要等到对方回复，才可以接续处理

79.@selector是什么？SEL，IMP是什么？

A. @selector是一个运算符。SEL，IMP是两种数据类型。IMP相当于函数指针，SEL类型标识了一个特定的方法，@selector用来获取特定方法的SEL值。

80.简述TCP/IP的分层，每层包含的常见协议

A.TCP/IP分为4层：链路层，网络层，传输层，应用层。链路层常见协议有ARP（地址转换协议），RARP（反向地址转换协议）；网络层主要协议是IP（网际协议），其它还有ICMP（Internet控制报文协议），IGMP（Internet组管理协议）；传输层，主要包括TCP（传输控制协议）和UDP（用户数据报协议）；应用层协议常见的有telnet,FTP等。

81 APNS苹果推送机制

 装有app应用得到 iOS 设备向 APNS 注册，APNS 向app应用返回一个ToKen，app向应用后台发送ToKen。
后台需要发送东西时，打包内容，然后把包和Token发送给APNS，APNS 发送给ios 设备。ios 设备发送给app。

82 运行时（runTime）

runtime通常我们翻译成运行时，其实就是程序运行的时候才加载执行。
面向对象编程语言的一种运行环境

83 反射机制

有时候我们需要通过类名来生成相应类的实例，这就用到反射机制。
两个对象的所有属性,用动态的方式取出来,并根据属性名,自动绑值需要通过类名来生成相应类的实例
http://www.cnblogs.com/jqyp/archive/2012/03/29/2423112.html

84  重用机制

我的理解是这样的：假设有n个cell，你的屏幕显示了k个cell（k<n），那么显示的时候会先初始化k个cell，在你向下滚动的时候，如果这个cell是已经alloc了，那么就会重用，而不会重新生成cell和里面的内容，也就是说cell被tableView缓存了；反之alloc，并且记录当前cell被重用。当你把tableView的cell都浏览完的时候，所有的cell都不需要alloc了，都会被重用。所以说UITableView的重用机制实际上是拿内存开销换来了显示的流畅，而不是节省了内存开销。
http://www.cnblogs.com/hellocby/archive/2012/05/23/2514469.html
http://blog.csdn.net/kiki1985/article/details/8710822

85 图形上下文

1.  在调用drawRect之前，视图对象会自动配置其描画环境，使得可以立即进行绘制。  
 2. UIView会为当前描画环境创建一个图形上下文（对应于CGContextRef封装类型）。该图形上下文，包括执行描画命令所需要的信息，定义各种基本的描画属性，比如描画使用的颜色，裁剪区域，线宽度，等等。
3. 在Quartz中，捕捉屏幕的描画命令，用于创建图像或者PDF文件,  使用CGBitmapContextCreate,   CGPDFContextCreate 来创建上下文。
   定制图形上下文的坐标系统和iPhone OS使用的本地坐标系统是不同的。与后者的坐标原点位于左上角不同的是,前者的坐标原点位于左下角,其坐标值向上向右递增。您在描画命令中指定的坐标必须对此加以考虑,否则,结果图像或PDF文件在渲染时就可能会发生错误。 
 4.  由于在位图或PDF上下文中进行描画时使用的是左下原点,所以在将描画结果渲染到视图上的时候,必须对坐标系统进行补偿。换句话说,如果您创建一个图像,并调用CGContextDrawImage函数来进行描画,则该图像在缺省情况下是上下颠倒的。为了纠正这个问题,您必须将CTM的y轴进行翻转(即将该值乘以-1),使其原点从左下角移动到视图的左上角。如果使用UIImage对象来包装您所创建的CGImageRef类型,则不需要修改CTM。UIImage对象会自动对CGImageRef 类型的坐标系统进行翻转补偿



86 instruments 检测app运行时内存泄漏问题

http://www.cocoachina.com/newbie/basic/2012/1204/5242.html

87   ARC 和 MRC 互换

1,编译标识来指明单个文件的方式
转为ARC:-fobjc-arc 
转为MRC: -fno-objc-arc 

2,整个工程转向ARC
选中工程->菜单edit->refactor->convert to Objective-c ARC

88  ios7 所改变的

http://blog.163.com/youthpasses@yeah/blog/static/161849228201351141614458/


89  开发者所需要知道的iOS7 SDK新特性

http://net.chinabyte.com/265/12700765.shtml

90  开发者所需要知道的iOS6 SDK新特性

http://onevcat.com/2012/06/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84ios6-sdk%E6%96%B0%E7%89%B9%E6%80%A7/








